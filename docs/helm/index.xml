<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Helm on Kubernetes Workshop</title><link>/kubernetes-workshop/helm/</link><description>Recent content in Helm on Kubernetes Workshop</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><atom:link href="/kubernetes-workshop/helm/index.xml" rel="self" type="application/rss+xml"/><item><title>nginx-ingress</title><link>/kubernetes-workshop/helm/nginx-ingress/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/nginx-ingress/</guid><description>Nmaespace 를 생성 합니다.
kubectl create namespace kube-ingress nginx-ingress 를 DaemonSet 으로 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install nginx-ingress stable/nginx-ingress --namespace kube-ingress --values - controller: kind: DaemonSet config: use-forwarded-headers: &amp;quot;true&amp;quot; service: annotations: service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: &amp;quot;3600&amp;quot; EOF 설치 내역을 확인 합니다.
helm list helm history nginx-ingress kubectl get pod,svc -n kube-ingress ELB 주소를 확인 합니다.
ELB_DOMAIN=&amp;quot;$(kubectl get svc -n kube-ingress | grep LoadBalancer | grep nginx-ingress-controller | awk '{print $4}')&amp;quot; ELB 주소를 Route53 에서 원하는 도메인의 CNAME 으로 등록 합니다.</description></item><item><title>cert-manager</title><link>/kubernetes-workshop/helm/cert-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/cert-manager/</guid><description>CustomResourceDefinition 을 생성 합니다.
kubectl apply \ --validate=false \ --filename=https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml jetstack Repository 를 등록 합니다.
helm repo add jetstack https://charts.jetstack.io helm repo update cert-manager 를 설치 합니다.
helm upgrade --install cert-manager jetstack/cert-manager \ --namespace kube-ingress \ --version v0.11.0 설치 내역을 확인 합니다.
helm list helm history cert-manager kubectl get pod,svc -n kube-ingress ClusterIssuer 를 설치 합니다. 이때 도메인 주인의 email 을 입력 하도록 합니다.</description></item><item><title>kube2iam</title><link>/kubernetes-workshop/helm/kube2iam/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/kube2iam/</guid><description> 환경 변수를 설정 합니다.
REGION=&amp;quot;ap-northeast-2&amp;quot; kube2iam 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install kube2iam stable/kube2iam --namespace kube-system --values - aws: region: ${REGION} extraArgs: auto-discover-base-arn: auto-discover-default-role: true host: iptables: true interface: eni+ rbac: create: true EOF</description></item><item><title>metrics-server</title><link>/kubernetes-workshop/helm/metrics-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/metrics-server/</guid><description> metrics-server 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install metrics-server stable/metrics-server --namespace kube-system --values - args: # enable this if you have self-signed certificates - --kubelet-insecure-tls - --kubelet-preferred-address-types=InternalIP,InternalDNS,ExternalDNS,ExternalIP,Hostname EOF</description></item><item><title>cluster-autoscaler</title><link>/kubernetes-workshop/helm/cluster-autoscaler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/cluster-autoscaler/</guid><description>환경 변수를 설정 합니다.
REGION=&amp;quot;ap-northeast-2&amp;quot; CLUSTER_NAME=&amp;quot;$(kubectl config current-context)&amp;quot; ACCOUNT=&amp;quot;$(aws sts get-caller-identity | grep &amp;quot;Account&amp;quot; | cut -d'&amp;quot;' -f4)&amp;quot; AWS_ROLE_ARN=&amp;quot;arn:aws:iam::${ACCOUNT}:role/${CLUSTER_NAME}-autoscaling&amp;quot; cluster-autoscaler 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install cluster-autoscaler stable/cluster-autoscaler --namespace kube-system --values - nameOverride: cluster-autoscaler awsRegion: ${REGION} autoDiscovery: enabled: true clusterName: ${CLUSTER_NAME} podAnnotations: iam.amazonaws.com/role: ${AWS_ROLE_ARN} extraArgs: v: 4 stderrthreshold: info logtostderr: true expander: random scale-down-enabled: true skip-nodes-with-local-storage: false skip-nodes-with-system-pods: false sslCertPath: /etc/ssl/certs/ca-bundle.crt rbac: create: true pspEnabled: true EOF 설치 내역을 확인 합니다.</description></item><item><title>efs-provisioner</title><link>/kubernetes-workshop/helm/efs-provisioner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/efs-provisioner/</guid><description> 환경 변수를 설정 합니다.
REGION=&amp;quot;ap-northeast-2&amp;quot; CLUSTER_NAME=&amp;quot;$(kubectl config current-context)&amp;quot; 현재의 EKS cluster 용으로 미리 만들어 놓은 EFS 의 ID 를 조회 합니다.
EFS_ID=&amp;quot;$(aws efs describe-file-systems --creation-token ${CLUSTER_NAME} --region ${REGION} | jq -r '.FileSystems[].FileSystemId')&amp;quot; efs-provisioner 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install efs-provisioner stable/efs-provisioner --namespace kube-system --values - efsProvisioner: efsFileSystemId: ${EFS_ID} awsRegion: ${REGION} path: /shared provisionerName: ${CLUSTER_NAME}/efs storageClass: name: efs isDefault: false gidAllocate: enabled: true gidMin: 40000 gidMax: 50000 reclaimPolicy: Retain EOF</description></item><item><title>prometheus</title><link>/kubernetes-workshop/helm/prometheus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/prometheus/</guid><description> Nmaespace 를 생성 합니다.
kubectl create namespace monitor prometheus 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install prometheus stable/prometheus --namespace monitor --values - server: persistentVolume: enabled: true accessModes: - ReadWriteOnce size: 8Gi storageClass: &amp;quot;efs&amp;quot; alertmanager: persistentVolume: enabled: true accessModes: - ReadWriteOnce size: 2Gi storageClass: &amp;quot;efs&amp;quot; EOF 설치 내역을 확인 합니다.
helm list helm history prometheus kubectl get pod,svc -n monitor</description></item><item><title>grafana</title><link>/kubernetes-workshop/helm/grafana/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/grafana/</guid><description>환경 변수를 설정 합니다.
PASSWORD=&amp;quot;password&amp;quot; # ROOT_DOMAIN=&amp;quot;mzdev.be&amp;quot; # BASE_DOMAIN=&amp;quot;spot.${ROOT_DOMAIN}&amp;quot; SERVICE_TYPE=&amp;quot;ClusterIP&amp;quot; INGRESS_ENABLED=true INGRESS_DOMAIN=&amp;quot;grafana-monitor.${BASE_DOMAIN}&amp;quot; grafana 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install grafana stable/grafana --namespace monitor --values - adminUser: admin adminPassword: ${PASSWORD} service: type: ${SERVICE_TYPE} ingress: enabled: ${INGRESS_ENABLED} annotations: cert-manager.io/cluster-issuer: &amp;quot;letsencrypt-prod&amp;quot; kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/ssl-redirect: &amp;quot;true&amp;quot; hosts: - ${INGRESS_DOMAIN} tls: - secretName: grafana-tls hosts: - ${INGRESS_DOMAIN} persistence: enabled: true accessModes: - ReadWriteOnce size: 5Gi storageClassName: &amp;quot;efs&amp;quot; EOF 설치 내역을 확인 합니다.</description></item><item><title>jenkins</title><link>/kubernetes-workshop/helm/jenkins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/jenkins/</guid><description>환경 변수를 설정 합니다.
PASSWORD=&amp;quot;password&amp;quot; # ROOT_DOMAIN=&amp;quot;mzdev.be&amp;quot; # BASE_DOMAIN=&amp;quot;spot.${ROOT_DOMAIN}&amp;quot; SERVICE_TYPE=&amp;quot;ClusterIP&amp;quot; INGRESS_ENABLED=true INGRESS_DOMAIN=&amp;quot;jenkins-devops.${BASE_DOMAIN}&amp;quot; Nmaespace 를 생성 합니다.
kubectl create namespace devops jenkins 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install jenkins stable/jenkins --namespace devops --values - master: adminUser: admin adminPassword: ${PASSWORD} resources: requests: cpu: 1000m memory: 3Gi limits: cpu: 2000m memory: 4Gi hostNetworking: true javaOpts: &amp;quot;-Dorg.apache.commons.jelly.tags.fmt.timeZone=Asia/Seoul&amp;quot; serviceType: ${SERVICE_TYPE} ingress: enabled: ${INGRESS_ENABLED} annotations: cert-manager.io/cluster-issuer: &amp;quot;letsencrypt-prod&amp;quot; kubernetes.</description></item><item><title>docker-registry</title><link>/kubernetes-workshop/helm/docker-registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/docker-registry/</guid><description> 환경 변수를 설정 합니다.
# ROOT_DOMAIN=&amp;quot;mzdev.be&amp;quot; # BASE_DOMAIN=&amp;quot;spot.${ROOT_DOMAIN}&amp;quot; SERVICE_TYPE=&amp;quot;ClusterIP&amp;quot; INGRESS_ENABLED=true INGRESS_DOMAIN=&amp;quot;docker-registry-devops.${BASE_DOMAIN}&amp;quot; docker-registry 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install docker-registry stable/docker-registry --namespace devops --values - service: type: ${SERVICE_TYPE} ingress: enabled: ${INGRESS_ENABLED} annotations: cert-manager.io/cluster-issuer: &amp;quot;letsencrypt-prod&amp;quot; ingress.kubernetes.io/proxy-body-size: 500m kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/proxy-body-size: 500m nginx.ingress.kubernetes.io/ssl-redirect: &amp;quot;true&amp;quot; hosts: - ${INGRESS_DOMAIN} path: / tls: - secretName: docker-registry-tls hosts: - ${INGRESS_DOMAIN} persistence: enabled: true accessMode: ReadWriteOnce size: 20Gi storageClass: &amp;quot;efs&amp;quot; EOF</description></item><item><title>chartmuseum</title><link>/kubernetes-workshop/helm/chartmuseum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/chartmuseum/</guid><description> 환경 변수를 설정 합니다.
# ROOT_DOMAIN=&amp;quot;mzdev.be&amp;quot; # BASE_DOMAIN=&amp;quot;spot.${ROOT_DOMAIN}&amp;quot; SERVICE_TYPE=&amp;quot;ClusterIP&amp;quot; INGRESS_ENABLED=true INGRESS_DOMAIN=&amp;quot;chartmuseum-devops.${BASE_DOMAIN}&amp;quot; chartmuseum 을 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install chartmuseum stable/chartmuseum --namespace devops --values - env: open: DISABLE_API: false service: type: ${SERVICE_TYPE} ingress: enabled: ${INGRESS_ENABLED} annotations: cert-manager.io/cluster-issuer: &amp;quot;letsencrypt-prod&amp;quot; ingress.kubernetes.io/proxy-body-size: 500m kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/proxy-body-size: 500m nginx.ingress.kubernetes.io/ssl-redirect: &amp;quot;true&amp;quot; hosts: - name: ${INGRESS_DOMAIN} path: / tls: true tlsSecret: chartmuseum-tls persistence: enabled: true accessMode: ReadWriteOnce size: 8Gi storageClass: &amp;quot;efs&amp;quot; EOF</description></item><item><title>sonatype-nexus</title><link>/kubernetes-workshop/helm/sonatype-nexus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/kubernetes-workshop/helm/sonatype-nexus/</guid><description>환경 변수를 설정 합니다.
PASSWORD=&amp;quot;password&amp;quot; # ROOT_DOMAIN=&amp;quot;mzdev.be&amp;quot; # BASE_DOMAIN=&amp;quot;spot.${ROOT_DOMAIN}&amp;quot; SERVICE_TYPE=&amp;quot;ClusterIP&amp;quot; INGRESS_ENABLED=true INGRESS_DOMAIN=&amp;quot;sonatype-nexus-devops.${BASE_DOMAIN}&amp;quot; sonatype-nexus 를 StatefulSet 으로 설치 합니다.
cat &amp;lt;&amp;lt; EOF | helm upgrade --install sonatype-nexus stable/sonatype-nexus --namespace devops --values - statefulset: enabled: true nexus: service: type: ${SERVICE_TYPE} resources: requests: cpu: 1000m memory: 3Gi limits: cpu: 2000m memory: 4Gi livenessProbe: initialDelaySeconds: 100 periodSeconds: 30 failureThreshold: 12 path: / readinessProbe: initialDelaySeconds: 100 periodSeconds: 30 failureThreshold: 12 path: / nexusProxy: env: nexusHttpHost: ${INGRESS_DOMAIN} nexusBackup: nexusAdminPassword: ${PASSWORD} ingress: enabled: ${INGRESS_ENABLED} annotations: cert-manager.</description></item></channel></rss>